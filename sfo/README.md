题目均来自《剑指offer》

| **考点** | 题目 |解答|
| :--- | :---: |:---: |
| 数组 |1. 二维数组中的查找|[2D array search](https://github.com/steveLauwh/Algorithms/blob/master/sfo/1.%202D%20array%20search.md)|
| 字符串 |2. 替换空格|[replace space](https://github.com/steveLauwh/Algorithms/blob/master/sfo/2.%20replace%20space.md)|
|链表|3. 从尾到头打印链表|[print list from tail to head](https://github.com/steveLauwh/Algorithms/blob/master/sfo/3.%20print%20list%20from%20tail%20to%20head.md)|
|递归和循环|4. 斐波那契数列|[fibonacci](https://github.com/steveLauwh/Algorithms/blob/master/sfo/4.%20fibonacci.md)|
|递归和循环|5. 跳台阶|[jump floor](https://github.com/steveLauwh/Algorithms/blob/master/sfo/5.%20jump%20floor.md)|
|栈和队列|6. 用两个栈实现队列|[implement a queue with two stacks](https://github.com/steveLauwh/Algorithms/blob/master/sfo/6.%20implement%20a%20queue%20with%20two%20stacks.md)|
|查找和排序|7. 旋转数组的最小数字|[min number in rotate array](https://github.com/steveLauwh/Algorithms/blob/master/sfo/7.%20min%20number%20in%20rotate%20array.md)|
|递归和循环|8. 变态跳台阶|[jump floor ii](https://github.com/steveLauwh/Algorithms/blob/master/sfo/8.%20jump%20floor%20ii.md)|
|树|9. 重建二叉树|[reconstruct binary tree](https://github.com/steveLauwh/Algorithms/blob/master/sfo/9.%20reconstruct%20binary%20tree.md)|
|位运算|10. 二进制中1的个数|[number of 1](https://github.com/steveLauwh/Algorithms/blob/master/sfo/10.%20number%20of%201.md)|
|代码的鲁棒性|11. 链表中倒数第k个结点|[find kth to tail](https://github.com/steveLauwh/Algorithms/blob/master/sfo/11.%20find%20kth%20to%20tail.md)|
|代码的鲁棒性|12. 反转链表|[reverse list](https://github.com/steveLauwh/Algorithms/blob/master/sfo/12.%20reverse%20list.md)|
|递归和循环|13. 矩形覆盖|[rect cover](https://github.com/steveLauwh/Algorithms/blob/master/sfo/13.%20rect%20cover.md)|
|代码的完整性|14. 调整数组顺序使奇数位于偶数前面|[reorder array](https://github.com/steveLauwh/Algorithms/blob/master/sfo/14.%20reorder%20array.md)|
|代码的完整性|15. 数值的整数次方|[power](https://github.com/steveLauwh/Algorithms/blob/master/sfo/15.%20power.md)|
|代码的鲁棒性|16. 合并两个排序的链表|[merge](https://github.com/steveLauwh/Algorithms/blob/master/sfo/16.%20merge.md)|
|面试思路|17. 二叉树的镜像|[mirror](https://github.com/steveLauwh/Algorithms/blob/master/sfo/17.%20mirror.md)|
|代码的鲁棒性|18. 树的子结构|[has subtree](https://github.com/steveLauwh/Algorithms/blob/master/sfo/18.%20has%20subtree.md)|
|举例让抽象具体化|19. 从上往下打印二叉树|[print from top to bottom](https://github.com/steveLauwh/Algorithms/blob/master/sfo/19.%20print%20from%20top%20to%20bottom.md)|
|举例让抽象具体化|20. 栈的压入、弹出序列|[is pop order](https://github.com/steveLauwh/Algorithms/blob/master/sfo/20.%20is%20pop%20order.md)|
|举例让抽象具体化|21. 包含min函数的栈|[ min stack](https://github.com/steveLauwh/Algorithms/blob/master/sfo/21.%20min%20stack.md)|
|画图让抽象形象化|22. 顺时针打印矩阵|[print matrix](https://github.com/steveLauwh/Algorithms/blob/master/sfo/22.%20print%20matrix.md)|
|时间效率|23. 数组中出现次数超过一半的数字|[more than half num](https://github.com/steveLauwh/Algorithms/blob/master/sfo/23.%20more%20than%20half%20num.md)|
|举例让抽象具体化|24. 二叉搜索树的后序遍历序列|[verify squence of BST](https://github.com/steveLauwh/Algorithms/blob/master/sfo/24.%20verify%20squence%20of%20BST.md)|
|时间效率|25. 最小的K个数|[get least numbers](https://github.com/steveLauwh/Algorithms/blob/master/sfo/25.%20%20get%20least%20numbers.md)|
|时间效率|26. 连续子数组的最大和|[find greatest sum of subarray](https://github.com/steveLauwh/Algorithms/blob/master/sfo/26.%20find%20greatest%20sum%20of%20subarray.md)|
|举例让抽象具体化|27. 二叉树中和为某一值的路径|[find path](https://github.com/steveLauwh/Algorithms/blob/master/sfo/27.%20find%20path.md)|
|知识迁移能力|28. 二叉树的深度|[tree depth](https://github.com/steveLauwh/Algorithms/blob/master/sfo/28.%20tree%20depth.md)|
|时间空间效率的平衡|29. 第一个只出现一次的字符位置|[first not repeating char](https://github.com/steveLauwh/Algorithms/blob/master/sfo/29.%20first%20not%20repeating%20char.md)|
|分解让复杂问题简单|30. 字符串的排列|[permutation](https://github.com/steveLauwh/Algorithms/blob/master/sfo/30.%20permutation.md)|
|发散思维能力|31. 求1+2+3+...+n|[sum](https://github.com/steveLauwh/Algorithms/blob/master/sfo/31.%20sum.md)|
|数组|32. 数组中重复的数字|[duplicate](https://github.com/steveLauwh/Algorithms/blob/master/sfo/32.%20duplicate.md)|
|时间空间效率的平衡|33. 两个链表的第一个公共结点|[find first common node](https://github.com/steveLauwh/Algorithms/blob/master/sfo/33.%20find%20first%20common%20node.md)|
|知识迁移能力|34. 数字在排序数组中出现的次数|[get number of k](https://github.com/steveLauwh/Algorithms/blob/master/sfo/34.%20get%20number%20of%20k.md)|
|分解让复杂问题简单|35. 复杂链表的复制|[clone](https://github.com/steveLauwh/Algorithms/blob/master/sfo/35.%20clone.md)|
|知识迁移能力|36. 数组中只出现一次的数字|[find nums appear once](https://github.com/steveLauwh/Algorithms/blob/master/sfo/36.%20find%20nums%20appear%20once.md)|
|时间效率|37. 把数组排成最小的数|[print min number](https://github.com/steveLauwh/Algorithms/blob/master/sfo/37.%20print%20min%20number.md)|
|时间空间效率的平衡|38. 丑数|[get ugly number](https://github.com/steveLauwh/Algorithms/blob/master/sfo/38.%20get%20ugly%20number.md)|
|知识迁移能力|39. 和为S的两个数字|[find numbers with sum](https://github.com/steveLauwh/Algorithms/blob/master/sfo/39.%20find%20numbers%20with%20sum.md)|
|时间效率|40. 整数中1出现的次数（从1到n整数中1出现的次数）|[number of 1 between 1 and N](https://github.com/steveLauwh/Algorithms/blob/master/sfo/40.%20number%20of%201%20between%201%20and%20N.md)|
|字符串|41. 左旋转字符串|[left rotate string](https://github.com/steveLauwh/Algorithms/blob/master/sfo/41.%20left%20rotate%20string.md)|
|字符串|42. 翻转单词顺序列|[reverse sentence](https://github.com/steveLauwh/Algorithms/blob/master/sfo/42.%20reverse%20sentence.md)|
|树和dfs|43. 平衡二叉树|[balanced binary tree](https://github.com/steveLauwh/Algorithms/blob/master/sfo/43.%20balanced%20binary%20tree.md)|
|链表|44. 删除链表中重复的结点|[delete duplication](https://github.com/steveLauwh/Algorithms/blob/master/sfo/44.%20delete%20duplication.md)|
|穷举|45. 和为S的连续正数序列|[find continuous sequence](https://github.com/steveLauwh/Algorithms/blob/master/sfo/45.%20find%20continuous%20sequence.md)|
|数学|46. 不用加减乘除做加法|[add](https://github.com/steveLauwh/Algorithms/blob/master/sfo/46.%20add.md)|
|链表|47. 链表中环的入口结点|[entry node of loop](https://github.com/steveLauwh/Algorithms/blob/master/sfo/47.%20entry%20node%20of%20loop.md)|
|数组|48. 数组中的逆序对|[inverse pairs](https://github.com/steveLauwh/Algorithms/blob/master/sfo/48.%20inverse%20pairs.md)|
|字符串和数学|49. 把字符串转换成整数|[str to int](https://github.com/steveLauwh/Algorithms/blob/master/sfo/49.%20str%20to%20int.md)|
|树|50. 对称的二叉树|[is symmetrical](https://github.com/steveLauwh/Algorithms/blob/master/sfo/50.%20is%20symmetrical.md)|
|树|51. 二叉树的下一个结点|[get next](https://github.com/steveLauwh/Algorithms/blob/master/sfo/51.%20get%20next.md)|
|字符串|52. 扑克牌顺子|[is continuous](https://github.com/steveLauwh/Algorithms/blob/master/sfo/52.%20is%20continuous.md)|
|链表|53. 孩子们的游戏(圆圈中最后剩下的数)|[last remaining](https://github.com/steveLauwh/Algorithms/blob/master/sfo/53.%20last%20remaining.md)|
|数组|54. 构建乘积数组|[multiply](https://github.com/steveLauwh/Algorithms/blob/master/sfo/54.%20multiply.md)|

